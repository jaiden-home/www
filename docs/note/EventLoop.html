<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环（Event Loop） | Jaiden</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/hero.jpg">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="程序员 web前端开发">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.770e0af4.css" as="style"><link rel="preload" href="/assets/js/app.6b7621a6.js" as="script"><link rel="preload" href="/assets/js/3.8aa8f030.js" as="script"><link rel="preload" href="/assets/js/4.cb6a11ed.js" as="script"><link rel="preload" href="/assets/js/5.0f050ebd.js" as="script"><link rel="prefetch" href="/assets/js/10.9bd0053b.js"><link rel="prefetch" href="/assets/js/11.415ac5de.js"><link rel="prefetch" href="/assets/js/12.668b98d1.js"><link rel="prefetch" href="/assets/js/13.d8d4dc5d.js"><link rel="prefetch" href="/assets/js/14.8179fe11.js"><link rel="prefetch" href="/assets/js/15.7179d332.js"><link rel="prefetch" href="/assets/js/16.157eb7d7.js"><link rel="prefetch" href="/assets/js/17.3f7ade6a.js"><link rel="prefetch" href="/assets/js/6.bad26671.js"><link rel="prefetch" href="/assets/js/7.c0d3b7ce.js"><link rel="prefetch" href="/assets/js/8.ce56086d.js"><link rel="prefetch" href="/assets/js/9.c84cf853.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.24e7f86f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.770e0af4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Jaiden</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/courseware/" class="nav-link">
  课件
</a></div><div class="nav-item"><a href="/resources/" class="nav-link">
  学习资源
</a></div> <a href="https://github.com/jaiden-home" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/courseware/" class="nav-link">
  课件
</a></div><div class="nav-item"><a href="/resources/" class="nav-link">
  学习资源
</a></div> <a href="https://github.com/jaiden-home" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>目录大纲</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/note/ECMAScriptInterpreter.html" class="sidebar-link">JavaScript 解析器</a></li><li><a href="/note/EventLoop.html" aria-current="page" class="active sidebar-link">事件循环（Event Loop）</a></li><li><a href="/note/BitOperation.html" class="sidebar-link">二进制原理（Bit Operation）</a></li><li><a href="/note/OOP.html" class="sidebar-link">面向对象（oop）</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="header-anchor">#</a> 事件循环（Event Loop）</h1> <h4 id="什么是-event-loop"><a href="#什么是-event-loop" class="header-anchor">#</a> 什么是 Event Loop？</h4> <p>为了协调事件，用户交互，脚本，渲染，联网等，必须使用事件循环。一个 JavaScript 运行时包含了一个待处理消息的消息集合。每个消息代理都有一个关联的事件循环，该循环对于该代理是唯一的。一个事件循环具有一个或多个任务队列。一个任务队列是一组任务。</p> <h4 id="运行时执行结构"><a href="#运行时执行结构" class="header-anchor">#</a> 运行时执行结构</h4> <p><img src="/assets/img/stack-queue-heap.c7e000dd.png" alt="堆栈队列"></p> <p><strong>栈 Stack</strong></p> <p>函数调用可能形成了一个由若干帧组成的栈。一帧可以理解成一个函数。</p> <p><strong>堆 Heap</strong></p> <p>对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。</p> <p><strong>队列 Queue</strong></p> <p>只允许在一端插入数据操作，在另一端进行删除数据操作的特殊线性表；进行插入操作的一端称为队尾（入队列），进行删除操作的一端称为队头（出队列）；队列具有先进先出（FIFO）的特性。</p> <p><code>java script</code>代码执行时，可以看成3大模块</p> <ul><li><p>堆模块，这里可以理解成数据储存块，声明的变量和对象都在这里，又称堆储存空间。</p></li> <li><p>栈模块，所有方法都要在这里执行，又称执行栈。</p></li> <li><p>队列模块，所有的消息，异步事件都在这里，又称消息队列。</p></li></ul> <p><code>ps</code>: 这里所讲的队列或消息队列，和线性表数据结构的队形完全不是一回事，没有先进先出（FIFO）的特性，这里的队形更像数据结构中的集合。消息队列中的消息一旦被消费就会出队列。下面提到的<strong>任务队列</strong>或<strong>微任务队列</strong>才是真正的FIFO队列。</p> <h4 id="事件循环流程图"><a href="#事件循环流程图" class="header-anchor">#</a> 事件循环流程图</h4> <p><img src="/assets/img/event-loop.5e8735ea.png" alt="Event Loop"></p> <p>在事件循环中消息队列是一个很重要的概念，为了消除网络请求系统IO等的耗时，javaScript执行时会将这些事件挂起当并绑定消息回调，等待系统触发回调时再加入执行栈。当执行栈再遇到异步事件又会将事件挂起以此反复。</p> <h4 id="事件循环代码执行流程图"><a href="#事件循环代码执行流程图" class="header-anchor">#</a> 事件循环代码执行流程图</h4> <p><img src="/assets/img/event-loop-code-flow.52fa149e.png" alt="work queue"></p> <p>一个事件循环具有一个或多个任务队列。一个任务队列是一组任务。</p> <p>例如，一次事件循环可以对计时器，网络请求等任务队列进行检查，将可执行的任务加入任务队列。这里有一个微任务的概念，就是说不需要检查直接要触发的事件比如<code>process.nextTick</code>,<code>Promises.then</code>, <code>MutationObserver</code>，也就是说要在检查可执行任务前加入任务队列，再加入可执行任务，推入执行栈。</p> <p><strong>代码实解：</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>    
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// browser: 1 2 3 4</span>
<span class="token comment">// ps: 低版本的node中，运行结果并不确定也有可能是: 1 2 4 3</span>
</code></pre></div><p>代码执行步骤：</p> <ol><li><code>Promise.then</code> 和 <code>setTimeout</code>都是异步任务</li> <li><code>Promise.then</code> 是微任务直接被加入任务队列</li> <li><code>setTimeout</code> 等待系统超时调用然后加入任务队列</li> <li><code>Promise.then</code> 和 <code>setTimeout</code> 推入执行栈</li> <li><code>Promise.then</code> 执行，输出1，并将内层<code>setTimeout</code> 加入消息集合，等待系统超时调用</li> <li><code>setTimeout</code> 执行，输出2，并直接将内层<code>Promise.then</code>加入任务队列</li> <li>内层<code>Promise.then</code> 和 内层<code>setTimeout</code> 推入执行栈</li> <li>内层<code>Promise.then</code> 执行，输出3</li> <li>内层<code>setTimeout</code>执行，输出4</li></ol> <p>结果是1 2 3 4 。</p> <p><code>ps</code>: 上面的代码在低版本的node中，运行结果并不确定也有可能是: 1 2 4 3 , 接下来开始讲讲node中的事件循环是咋回事。</p> <h4 id="node-js中的event-loop"><a href="#node-js中的event-loop" class="header-anchor">#</a> <code>Node.js</code>中的Event Loop</h4> <p>首先想了解一下<code>Node.js</code>的构成；</p> <p><img src="/assets/img/node-system.20c8ec0e.png" alt="node-system"></p> <p>一个<code>Node.js</code>的应用由<code>V8</code>引擎提供给<code>javaScript</code>运行时，然后<code>V8</code>通过<code>Node.js</code>的<code>api</code>调用<code>Node.js</code>的虚拟机（<code>libuv</code>）,	由<code>libuv</code>提供给<code>V8</code>的系统操作能力。</p> <p>在 <code>Node.js</code> 中，<code>V8</code>只是<code>javaScript</code>运行时。<code>libuv</code> 提供了一个线程池处理诸如文件 I/O 等高成本的任务。所以node并不是单线程的。 在 <code>Node.js</code> 中，有两种类型的线程：一个事件循环线程（也被称为主循环，主线程，事件线程等）。另外一个是在工作线程池里的 <code>k</code> 个工作线程（也被称为线程池）。</p> <p><code>Node.js</code> 使用事件驱动机制：它有一个事件轮询线程负责任务编排，和一个专门处理繁重任务的工作线程池。</p> <p>例如 <code>Node.js</code> 程序运行时，程序首先完成初始化部分，即处理 <code>require</code> 加载的模块和注册事件回调。 然后，<code>Node.js</code> 应用程序进入事件循环阶段，通过执行对应回调函数来对客户端请求做出回应。 此回调将同步执行，并且可能在完成之后继续注册新的异步请求。 这些异步请求的回调也会在事件轮询线程中被处理。</p> <p>事件轮询线程本身并不维护队列，而是去监听操作系统变化，把它转换成合适的事件，然后触发与该事件对应的回调函数。</p> <p>相对而言，工作线程池则使用一个真实的(FIFO)队列，里边装的都是要被处理的任务。 一个工作线程从这个队列中取出一个任务，开始处理它。当完成之后这个工作线程向事件循环线程中发出一个“任务完成了”的消息。</p> <p>保证永远不要阻塞事件轮询线程。 换句话说，每个 JavaScript 回调应该快速完成。 这些当然对于 <code>await</code>，<code>Promise.then</code> 也同样适用。</p> <p>下面的图表展示了事件循环操作顺序的简化概览。</p> <p><img src="/assets/img/node-event-loop.3b819c14.png" alt="Node.js Event Loop"></p> <h4 id="node-js工作队列阶段概述"><a href="#node-js工作队列阶段概述" class="header-anchor">#</a> <code>Node.js</code>工作队列阶段概述</h4> <ul><li><strong>定时器</strong>：本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li> <li><strong>待定回调</strong>：执行延迟到下一个循环迭代的 I/O 回调。</li> <li><strong>idle, prepare</strong>：仅系统内部使用。</li> <li><strong>轮询</strong>：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 <code>setImmediate()</code> 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li> <li><strong>检测</strong>：<code>setImmediate()</code> 回调函数在这里执行。</li> <li><strong>关闭的回调函数</strong>：一些关闭的回调函数，如：<code>socket.on('close', ...)</code>。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// demo 1</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 1 2 or  2 1</span>

<span class="token comment">// demo 2</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2 1</span>
</code></pre></div><p>demo 1的结果是不确定的，demo 2的结果则永远不变的。demo 1结果的原因就是：<code>setTimeout</code> ，<code>setImmediate</code> 在从主模块内被调用，事件轮询线程将最先调用可执行的方法。换句话说：事件轮询线程没有队列机制谁快调用谁。<code>setTimeout</code> 方法受到系统环境影响，有可能在<code>setImmediate</code>方法后别调用。这也解释了为什么在老版本的<code>Node.js</code>为什么结果可能是 1 2 4 3的原因。</p> <p>demo 2 为什么结果就是确定的呢，原因是: <code>fs.readFile</code>这个是工作线程中调用，当完成之后通知事件轮询线程，然后事件轮询线程将轮询下一个步骤，check阶段，<code>setImmediate</code>此时被调用，然后接着下一步骤 close callbacks 阶段，最后轮询结束，进入新的轮询，timers   阶段，此时定时器被调用。这就是为什么结果一定是 2 1原因。</p> <p>总结：</p> <ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li> <li>主线程之外，还用一个工作线程，维护一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</li> <li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li> <li>主线程不断重复上面的第三步。</li></ol> <h4 id="工作线程-process-nexttick"><a href="#工作线程-process-nexttick" class="header-anchor">#</a> 工作线程 <code>process.nextTick</code></h4> <p>工作线程维护了一个(FIFO)队列，在上图中事件循环操步骤中并没有<code>process.nextTick</code>步骤，但其实它是工作线程的队列操作方法，而且两个<code>API</code>类似，但它们的名称令人费解。实质上，这两个名称应该交换，因为 <code>process.nextTick</code> 比 <code>setImmediate</code> 触发得更快，<code>process.nextTick</code> 在每次轮询前触发，<code>setImmediate</code> 在事件循环的接下来的迭代或 'tick' 上触发。也就是说，<code>process.nextTick</code>指定的任务总是发生在所有异步任务之前。<code>setImmediate()</code> 是当前轮询阶段完成后就触发。议开发人员在所有情况下都使用 <code>setImmediate</code>，因为它更容易理解。</p> <p><strong><code>process.nextTick()</code> 对比 <code>setImmediate()</code></strong></p> <ul><li><code>process.nextTick</code> 比 <code>setImmediate</code> 触发得更快。</li></ul> <ul><li><code>process.nextTick()</code> 在同一个阶段立即执行。</li> <li><code>setImmediate()</code> 在事件循环的接下来的迭代或 <code>tick</code> 上触发。</li> <li><code>process.nextTick</code> 可以阻止事件循环到达轮询阶段(递归)。</li></ul> <h4 id="两个事件循环机制的区别"><a href="#两个事件循环机制的区别" class="header-anchor">#</a> 两个事件循环机制的区别</h4> <ul><li>浏览器中的事件循环有一个微任务队列，这使得一些异步方法每一次都会在前面调用。</li> <li><code>Node.js</code>有两个（两个类型）线程，工作线程负责异步队列调用。</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/jaiden-home/www/edit/master/blog/note/EventLoop.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2/8/2023, 6:28:45 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/ECMAScriptInterpreter.html" class="prev">
        JavaScript 解析器
      </a></span> <span class="next"><a href="/note/BitOperation.html">
        二进制原理（Bit Operation）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.6b7621a6.js" defer></script><script src="/assets/js/3.8aa8f030.js" defer></script><script src="/assets/js/4.cb6a11ed.js" defer></script><script src="/assets/js/5.0f050ebd.js" defer></script>
  </body>
</html>
